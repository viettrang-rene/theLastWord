<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Fun Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Poppins font from Google Fonts (for crossword/word search styling) -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;300;800&display=swap" rel="stylesheet">
    <!-- PDF-LIB for PDF generation -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Crossword Layout Generator -->
    <script src="https://unpkg.com/crossword-layout-generator@1.0.0/dist/crossword-layout-generator.umd.js"></script>
    <style>
        /* General Body and App Container Styling (from previous version, using Inter font) */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            transition: border-color 0.3s ease-in-out;
            border: 2px solid transparent; /* Default border */
        }
        .theme-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            color: white;
        }
        .theme-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .theme-easy-animals { background-color: #4CAF50; } /* Green */
        .theme-farm-animals { background-color: #8B4513; } /* Brown */
        .theme-ocean-animals { background-color: #2196F3; } /* Blue */

        .generate-button {
            background-color: #4F46E5; /* Indigo */
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .generate-button:hover {
            background-color: #4338CA;
            transform: translateY(-2px);
        }
        .generate-button:disabled {
            background-color: #9CA3AF;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        textarea {
            min-height: 150px;
            border-radius: 0.75rem;
            padding: 1rem;
            border: 2px solid #D1D5DB;
            transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #4F46E5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }
        .error-message {
            color: #EF4444; /* Red */
            font-weight: 600;
            margin-top: 0.5rem;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4F46E5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Interactive Puzzle Specific Styles (from user's reference) --- */
        /* Reset Poppins font for specific puzzle elements */
        .game-container, .word-search-container, .puzzle-grid, .clues {
            font-family: 'Poppins', sans-serif;
        }

        .game-container {
            padding: 10px;
            display: flex;
            width: 100%;
            justify-content: space-around;
            min-height: 100vh; /* Adjust for overall app height */
            align-items: flex-start; /* Align to top */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px; /* Space between puzzle sections */
        }

        .puzzle-grid {
            display: grid;
            /* grid-template-rows will be set dynamically by JS */
            box-shadow: rgba(17, 12, 46, 0.15) 0px 48px 100px 0px;
            background-color: white; /* Ensure background for grid */
            border-radius: 0.5rem; /* Rounded corners for the grid container */
            overflow: hidden; /* Hide overflow from cells */
        }

        .puzzle-grid .row {
            display: grid;
            /* grid-template-columns will be set dynamically by JS */
        }

        .puzzle-grid .cell {
            width: 40px; /* Default cell size */
            height: 40px; /* Default cell size */
            background-color: white;
            border: 1px solid green;
            position: relative; /* For number positioning */
            display: flex; /* For input centering */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Clip content if it overflows */
        }

        .puzzle-grid .inactive {
            background-color: green;
        }

        .puzzle-grid h1 {
            text-align: center;
            color: green;
            font-size: 2.2rem;
            position: absolute; /* Keep title absolute if needed, but consider flow */
            top: 2px;
            width: 100%;
        }

        .puzzle-grid .number {
            position: absolute; /* Changed to absolute for better control within cell */
            font-weight: 300;
            color: #000;
            top: 2px; /* Position at top-left of cell */
            left: 3px;
            font-size: small;
            z-index: 10;
        }

        .puzzle-grid input {
            display: block;
            position: relative; /* Relative to cell */
            font-size: 16px;
            text-align: center;
            height: 100%; /* Fill cell height */
            width: 100%; /* Fill cell width */
            background-color: transparent;
            border: none;
            z-index: 1;
            padding: 0; /* Remove default padding */
            margin: 0; /* Remove default margin */
            box-sizing: border-box; /* Include padding/border in width/height */
        }

        .puzzle-grid input:focus {
            outline: none;
            background-color: #bddebe;
        }

        .clues {
            flex: 1; /* Allow clues to take available space */
            min-width: 300px; /* Minimum width for clues section */
            max-width: 40%;
            padding: 10px;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: rgba(17, 12, 46, 0.15) 0px 48px 100px 0px;
        }

        .clues h2 {
            font-size: 1.5rem;
            color: green;
            text-align: center;
            margin-bottom: 15px;
        }

        .clues table {
            font-family: 'Poppins', sans-serif; /* Apply Poppins to table */
            border-collapse: collapse;
            width: 100%;
        }

        .clues td, .clues th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        .clues tr:nth-child(even) {
            background-color: #dddddd;
        }
        .clues button {
            background-color: green;
            color: #fff;
            border-radius: 5px;
            font-family: 'Poppins', sans-serif;
            border: 2px solid transparent;
            padding: 5px 10px; /* Adjusted padding for smaller buttons */
            font-size: 0.85rem; /* Smaller font for buttons */
            cursor: pointer;
            transition: all .2s ease;
        }
        .clues button:hover {
            background-color: #fff;
            border: 2px solid green;
            color: green;
        }
        .clues .answer-text {
            visibility: hidden;
            color: green;
            display: inline-block; /* To allow it next to button */
            margin-left: 10px;
        }
        .clues button:hover + .answer-text {
            visibility: visible;
        }

        /* Word Search Specific Styles (from user's reference) */
        .word-search-container {
            margin: 30px auto;
            flex: 1; /* Allow word search to take available space */
            min-width: 300px; /* Minimum width for word search */
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: rgba(17, 12, 46, 0.15) 0px 48px 100px 0px;
            padding: 15px;
        }
        .word-search {
            border: 2px solid #4a89dc;
            border-collapse: collapse;
            margin: 0 auto;
            background-color: #e6f2ff;
            border-radius: 8px; /* Apply border-radius to the table itself */
            overflow: hidden; /* Hide overflow for rounded corners */
        }
        .word-search td {
            width: 30px;
            height: 30px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            border: 1px solid #b3d1ff;
            background-color: #e6f2ff;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
        }
        .word-search td:hover {
            background-color: #cce0ff;
        }
        .word-search td.found-word {
            background-color: #ffebee !important;
            color: #c62828 !important;
            border-color: #ef9a9a !important;
        }
        .word-list {
            margin: 20px 0;
            padding: 15px;
            background-color: #e6f2ff;
            border-radius: 8px;
            border: 1px solid #b3d1ff;
        }
        .word-list h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .word-list ul {
            list-style-type: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        .word-list li {
            font-size: 18px;
            font-weight: bold;
            padding: 8px 15px;
            border-radius: 6px;
            background-color: #d9e6ff;
            color: #2c3e50;
        }
        .word-list li.found {
            background-color: #ffebee;
            color: #c62828;
            position: relative;
        }
        .word-list li.found::after {
            content: "";
            position: absolute;
            left: 10%;
            top: 50%;
            width: 80%;
            height: 2px;
            background-color: #c62828;
            transform: translateY(-50%);
        }
        .highlight {
            background-color: #fff3e0;
        }
        .stats {
            margin: 20px 0;
            font-size: 18px;
            background-color: #e6f2ff;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #b3d1ff;
        }
        .congrats {
            color: #c62828;
            font-weight: bold;
            font-size: 20px;
            margin: 20px 0;
            padding: 15px;
            background-color: #ffebee;
            border-radius: 8px;
            display: none;
        }
        .pdf-download-message {
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: #d1fae5; /* Green-100 */
            color: #065f46; /* Green-900 */
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 500;
            display: none;
        }

        /* Media Queries for responsiveness */
        @media screen and (max-width: 980px) {
            .game-container {
                flex-direction: column;
                align-items: center;
                padding-top: 70px;
                gap: 30px;
            }
            .puzzle-grid, .word-search-container, .clues {
                max-width: 100%;
                width: 100%; /* Ensure they take full width */
            }
            .puzzle-grid .cell, .word-search td {
                width: 35px; /* Adjust cell size for tablets */
                height: 35px;
            }
            .puzzle-grid input {
                font-size: 0.9rem;
            }
            .puzzle-grid .number {
                font-size: 0.7rem;
            }
            .word-search td {
                font-size: 18px;
            }
        }

        @media screen and (max-width: 480px) {
            .puzzle-grid .cell, .word-search td {
                width: 27px; /* Adjust cell size for mobile */
                height: 27px;
            }
            .puzzle-grid input {
                font-size: 0.7rem;
            }
            .puzzle-grid .number {
                font-size: 0.5rem;
                top: 1px;
                left: 2px;
            }
            .word-search td {
                font-size: 16px;
            }
            .clues button {
                padding: 3px 8px;
                font-size: 0.75rem;
            }
            .clues td, .clues th {
                padding: 5px;
            }
            .word-list li {
                font-size: 16px;
                padding: 6px 10px;
            }
            .stats {
                font-size: 16px;
                padding: 10px;
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="input-section" class="container">
        <h1 class="text-4xl font-extrabold text-center text-gray-900 mb-4">Puzzle Fun Generator! 2</h1>
        <p class="text-md text-center text-gray-600 mb-8">Create custom crossword and word search puzzles.</p>

        <div class="flex flex-col md:flex-row gap-4 mb-6">
            <div class="flex-1">
                <label for="wordInput" class="block text-lg font-semibold text-gray-700 mb-2">Enter your words:</label>
                <textarea
                    id="wordInput"
                    class="w-full focus:ring-indigo-500 focus:border-indigo-500"
                    placeholder="Enter words (e.g., apple, banana, dolphin) or pick a theme below."
                ></textarea>
                <p id="errorMessage" class="error-message hidden">Only letters allowed. Please try again!</p>
            </div>
            <div class="md:w-1/3 flex flex-col gap-3">
                <label class="block text-lg font-semibold text-gray-700 mb-2">Or choose a theme:</label>
                <button id="easyAnimalsBtn" class="theme-button theme-easy-animals">Easy Animals</button>
                <button id="farmAnimalsBtn" class="theme-button theme-farm-animals">Farm Animals</button>
                <button id="oceanAnimalsBtn" class="theme-button theme-ocean-animals">Ocean Animals</button>
                <button id="resetBtn" class="generate-button bg-gray-500 hover:bg-gray-600 mt-4">Reset</button>
            </div>
        </div>

        <button id="generatePuzzlesBtn" class="generate-button w-full">Generate Puzzles</button>
    </div>

    <div id="puzzles-section" class="container hidden">
        <h1 class="text-4xl font-extrabold text-center text-gray-900 mb-4">
            Your Puzzles! <span id="iteration-label" class="text-xl text-gray-500 font-normal ml-2"></span>
        </h1>
        <p class="text-md text-center text-gray-600 mb-8">Interact with them below or print to PDF.</p>

        <div class="game-container">
            <!-- Interactive Crossword Puzzle -->
            <div id="interactive-crossword-wrapper" class="flex flex-col items-center flex-1 min-w-[300px]">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Crossword Puzzle</h2>
                <div id="interactive-crossword-grid" class="puzzle-grid">
                    <!-- Crossword grid will be dynamically inserted here -->
                </div>
                <div id="interactive-crossword-clues" class="clues mt-4">
                    <h2>Clues</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Clue</th>
                                <th>Answer</th>
                            </tr>
                        </thead>
                        <tbody id="crossword-clues-body">
                            <!-- Clues will be dynamically inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Interactive Word Search Puzzle -->
            <div id="interactive-wordsearch-wrapper" class="flex flex-col items-center flex-1 min-w-[300px]">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Word Search Puzzle</h2>
                <div class="stats hidden">
                    Found: <span id="found-count">0</span> of <span id="total-words">0</span> words
                </div>
                <div class="congrats" id="congrats-message">
                    Congratulations! You found all the words!
                </div>
                <div class="word-list hidden">
                    <h3>Words to find:</h3>
                    <ul id="words-to-find"></ul>
                </div>
                <div class="word-search-container">
                    <table class="word-search" id="wordSearch"></table>
                </div>
            </div>
        </div>

        <button id="printPdfBtn" class="generate-button w-full mt-8">Print to PDF</button>
        <div id="pdf-download-message" class="pdf-download-message">
            Your PDF should be opening in a new tab or downloading. If not, please check your browser's pop-up blocker settings.
        </div>
        <button id="backToInputBtn" class="generate-button bg-gray-500 hover:bg-gray-600 w-full mt-4">Back to Input</button>
    </div>

    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>Generating your puzzles...</p>
        <p class="text-sm text-gray-500">This might take a moment as we fetch images and create the PDF.</p>
    </div>

    <script>
        const { PDFDocument, rgb, StandardFonts } = PDFLib;

        // --- UI Elements ---
        const wordInput = document.getElementById('wordInput');
        const errorMessage = document.getElementById('errorMessage');
        const easyAnimalsBtn = document.getElementById('easyAnimalsBtn');
        const farmAnimalsBtn = document.getElementById('farmAnimalsBtn');
        const oceanAnimalsBtn = document.getElementById('oceanAnimalsBtn');
        const resetBtn = document.getElementById('resetBtn');
        const generatePuzzlesBtn = document.getElementById('generatePuzzlesBtn'); // Renamed from generatePdfBtn
        const printPdfBtn = document.getElementById('printPdfBtn'); // New button
        const backToInputBtn = document.getElementById('backToInputBtn'); // New button
        const appContainer = document.getElementById('input-section'); // Renamed to input-section
        const puzzlesSection = document.getElementById('puzzles-section'); // New section for puzzles
        const loadingOverlay = document.getElementById('loadingOverlay');
        const iterationLabel = document.getElementById('iteration-label'); // New element for iteration number
        const pdfDownloadMessage = document.getElementById('pdf-download-message'); // New element for PDF download message

        // Interactive Crossword Elements
        const interactiveCrosswordGrid = document.getElementById('interactive-crossword-grid');
        const crosswordCluesBody = document.getElementById('crossword-clues-body');

        // Interactive Word Search Elements
        const wordSearchTable = document.getElementById('wordSearch');
        const statsDiv = document.querySelector('#puzzles-section .stats');
        const foundCountSpan = document.getElementById('found-count');
        const totalWordsSpan = document.getElementById('total-words');
        const congratsMessage = document.getElementById('congrats-message');
        const wordsToFindList = document.getElementById('words-to-find');
        const wordListDiv = document.querySelector('#puzzles-section .word-list');


        // --- Theme Colors ---
        const themeColors = {
            'easyAnimals': { ui: '#4CAF50', pdf: rgb(0.29, 0.69, 0.29) }, // Green
            'farmAnimals': { ui: '#8B4513', pdf: rgb(0.55, 0.27, 0.07) }, // Brown
            'oceanAnimals': { ui: '#2196F3', pdf: rgb(0.13, 0.59, 0.95) }  // Blue
        };
        let currentThemeColor = null;

        // --- Pre-defined Themes ---
        const themes = {
            'easyAnimals': ['cat', 'dog', 'bird', 'fish', 'bear', 'lion', 'zebra', 'mouse'],
            'farmAnimals': ['cow', 'pig', 'chicken', 'sheep', 'horse', 'goat', 'duck', 'barn'],
            'oceanAnimals': ['dolphin', 'whale', 'shark', 'octopus', 'crab', 'jellyfish', 'seahorse', 'starfish']
        };

        // --- Puzzle Data Storage ---
        let generatedCrosswordLayouts = []; // Can hold one or more layouts (main + standalones)
        let generatedWordSearchGrid = [];
        let activeWordsForPuzzles = []; // Words used for current puzzles
        let puzzleIteration = 0; // New variable to track iteration number

        // --- Word Search specific global variables ---
        let wsGrid = [];
        let wsWordPositions = {};
        let wsFoundWords = new Set();
        let wsGridSize = 15; // Default word search grid size

        // --- Helper Functions ---

        /**
         * Scrambles a given word.
         * @param {string} word - The word to scramble.
         * @returns {string} The scrambled word.
         */
        function scrambleWord(word) {
            if (word.length <= 1) return word;
            const a = word.split("");
            let n = a.length;
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
            return a.join("");
        }

        /**
         * Validates the input words to ensure they only contain letters.
         * @param {string} input - The raw input string from the textarea.
         * @returns {boolean} True if all words are valid, false otherwise.
         */
        function validateInput(input) {
            const words = input.split(/[\n,]+/).map(word => word.trim()).filter(word => word.length > 0);
            for (const word of words) {
                if (!/^[a-zA-Z]+$/.test(word)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Applies the selected theme's accent color to UI elements.
         * @param {string} themeName - The name of the selected theme.
         */
        function applyThemeStyling(themeName) {
            currentThemeColor = themeColors[themeName];
            if (currentThemeColor) {
                appContainer.style.borderColor = currentThemeColor.ui;
                generatePuzzlesBtn.style.backgroundColor = currentThemeColor.ui;
                generatePuzzlesBtn.style.setProperty('--tw-bg-opacity', '1'); // Ensure Tailwind opacity is overridden
                generatePuzzlesBtn.onmouseover = () => generatePuzzlesBtn.style.backgroundColor = darkenColor(currentThemeColor.ui, 10);
                generatePuzzlesBtn.onmouseout = () => generatePuzzlesBtn.style.backgroundColor = currentThemeColor.ui;
                wordInput.style.borderColor = currentThemeColor.ui;
                wordInput.style.boxShadow = `0 0 0 3px ${currentThemeColor.ui}33`; // Add a subtle shadow
            }
        }

        /**
         * Darkens a hex color by a given percentage.
         * @param {string} hex - The hex color string (e.g., #RRGGBB).
         * @param {number} percent - The percentage to darken (0-100).
         * @returns {string} The darkened hex color.
         */
        function darkenColor(hex, percent) {
            let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=(f>>8)&0x00FF,B=(f&0x0000FF);
            return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
        }

        /**
         * Clears all inputs and resets styling.
         */
        function resetApp() {
            wordInput.value = '';
            errorMessage.classList.add('hidden');
            appContainer.style.borderColor = 'transparent';
            generatePuzzlesBtn.style.backgroundColor = '#4F46E5'; // Reset to default indigo
            generatePuzzlesBtn.onmouseover = null;
            generatePuzzlesBtn.onmouseout = null;
            wordInput.style.borderColor = '#D1D5DB';
            wordInput.style.boxShadow = 'none';
            currentThemeColor = null;
            // Clear puzzle data
            generatedCrosswordLayouts = [];
            generatedWordSearchGrid = [];
            activeWordsForPuzzles = [];
            puzzleIteration = 0; // Reset iteration number
            iterationLabel.textContent = ''; // Clear iteration label
            pdfDownloadMessage.style.display = 'none'; // Hide PDF message
            // Hide puzzle section
            puzzlesSection.classList.add('hidden');
            appContainer.classList.remove('hidden');
        }

        /**
         * Generates a random character (uppercase letter).
         * @returns {string} A random uppercase letter.
         */
        function getRandomChar() {
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }

        // --- Word Search Logic (adapted from user's reference) ---
        const wsDirections = [
            [1, 0], [0, 1], [1, 1], [-1, 1],
            [-1, 0], [0, -1], [-1, -1], [1, -1]
        ];

        function wsCanPlaceWord(word, row, col, direction) {
            const [rowDir, colDir] = direction;
            const endRow = row + (word.length - 1) * rowDir;
            const endCol = col + (word.length - 1) * colDir;

            if (endRow < 0 || endRow >= wsGridSize || endCol < 0 || endCol >= wsGridSize) {
                return false;
            }

            for (let i = 0; i < word.length; i++) {
                const r = row + i * rowDir;
                const c = col + i * colDir;

                if (wsGrid[r][c] !== '' && wsGrid[r][c] !== word[i]) {
                    return false;
                }
            }
            return true;
        }

        function wsPlaceWord(word) {
            let placed = false;
            let attempts = 0;

            while (!placed && attempts < 100) {
                attempts++;
                const direction = wsDirections[Math.floor(Math.random() * wsDirections.length)];
                const [rowDir, colDir] = direction;

                let row, col;

                if (rowDir === 1) {
                    row = Math.floor(Math.random() * (wsGridSize - word.length));
                } else if (rowDir === -1) {
                    row = Math.floor(Math.random() * (wsGridSize - word.length)) + word.length - 1;
                } else {
                    row = Math.floor(Math.random() * wsGridSize);
                }

                if (colDir === 1) {
                    col = Math.floor(Math.random() * (wsGridSize - word.length));
                } else if (colDir === -1) {
                    col = Math.floor(Math.random() * (wsGridSize - word.length)) + word.length - 1;
                } else {
                    col = Math.floor(Math.random() * wsGridSize);
                }

                if (wsCanPlaceWord(word, row, col, direction)) {
                    wsWordPositions[word] = {
                        start: {row, col},
                        direction: [rowDir, colDir],
                        letters: []
                    };

                    for (let i = 0; i < word.length; i++) {
                        const r = row + i * rowDir;
                        const c = col + i * colDir;
                        wsGrid[r][c] = word[i];
                        wsWordPositions[word].letters.push({row: r, col: c});
                    }
                    placed = true;
                }
            }
            return placed;
        }

        function wsFillEmptySpaces() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < wsGridSize; i++) {
                for (let j = 0; j < wsGridSize; j++) {
                    if (wsGrid[i][j] === '') {
                        wsGrid[i][j] = letters.charAt(Math.floor(Math.random() * letters.length));
                    }
                }
            }
        }

        function wsRenderGrid() {
            wordSearchTable.innerHTML = '';

            for (let i = 0; i < wsGridSize; i++) {
                const row = document.createElement('tr');

                for (let j = 0; j < wsGridSize; j++) {
                    const cell = document.createElement('td');
                    cell.textContent = wsGrid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    row.appendChild(cell);
                }
                wordSearchTable.appendChild(row);
            }
            wsAddCellClickListeners();
        }

        function wsAddCellClickListeners() {
            const cells = document.querySelectorAll('#wordSearch td');
            cells.forEach(cell => {
                cell.removeEventListener('click', wsHandleCellClick); // Prevent duplicate listeners
                cell.addEventListener('click', wsHandleCellClick);
            });
        }

        function wsHandleCellClick(event) {
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            for (const word in wsWordPositions) {
                const positions = wsWordPositions[word].letters;
                const isPartOfWord = positions.some(pos => pos.row === row && pos.col === col);

                if (isPartOfWord && !wsFoundWords.has(word)) {
                    wsHighlightWord(word);
                    wsFoundWords.add(word);
                    wsMarkWordAsFound(word);
                    wsUpdateFoundCount();
                    return;
                }
            }

            // If not part of a word, provide temporary highlight
            cell.classList.add('highlight');
            setTimeout(() => {
                cell.classList.remove('highlight');
            }, 500);
        }

        function wsHighlightWord(word) {
            const positions = wsWordPositions[word].letters;
            positions.forEach(pos => {
                const cell = document.querySelector(`#wordSearch td[data-row="${pos.row}"][data-col="${pos.col}"]`);
                if (cell) {
                    cell.classList.add('found-word');
                }
            });
        }

        function wsMarkWordAsFound(word) {
            const wordElement = document.querySelector(`#words-to-find li[data-word="${word}"]`);
            if (wordElement) {
                wordElement.classList.add('found');
            }
        }

        function wsUpdateFoundCount() {
            foundCountSpan.textContent = wsFoundWords.size;
            totalWordsSpan.textContent = activeWordsForPuzzles.length;

            if (wsFoundWords.size === activeWordsForPuzzles.length && activeWordsForPuzzles.length > 0) {
                congratsMessage.style.display = 'block';
            } else {
                congratsMessage.style.display = 'none';
            }
        }

        function wsInitializeGrid() {
            wsGrid = [];
            wsWordPositions = {};
            wsFoundWords.clear();
            wsUpdateFoundCount();
            congratsMessage.style.display = 'none';

            for (let i = 0; i < wsGridSize; i++) {
                wsGrid[i] = [];
                for (let j = 0; j < wsGridSize; j++) {
                    wsGrid[i][j] = '';
                }
            }

            wordsToFindList.innerHTML = '';
            activeWordsForPuzzles.forEach(word => {
                const li = document.createElement('li');
                li.textContent = word;
                li.dataset.word = word;
                wordsToFindList.appendChild(li);
            });

            const cells = document.querySelectorAll('#wordSearch td');
            cells.forEach(cell => {
                cell.classList.remove('found-word');
            });
        }

        function generateInteractiveWordSearch() {
            wsGridSize = Math.max(12, Math.ceil(Math.sqrt(activeWordsForPuzzles.join('').length)) + 3);
            wsInitializeGrid();

            // Sort words by length (longest first) for better placement
            const wordsForWS = [...activeWordsForPuzzles].sort((a, b) => b.length - a.length);

            let allPlaced = true;
            wordsForWS.forEach(word => {
                if (!wsPlaceWord(word)) {
                    console.warn(`Could not place word in interactive word search: ${word}`);
                    allPlaced = false;
                }
            });

            if (!allPlaced) {
                // This alert should ideally be a more subtle message on the UI
                console.warn("Some words couldn't be placed in the interactive word search. Try with fewer or shorter words.");
            }

            wsFillEmptySpaces();
            wsRenderGrid();

            statsDiv.style.display = 'block';
            wordListDiv.style.display = 'block';
        }


        // --- Interactive Crossword Logic ---
        function renderInteractiveCrossword(layout, containerElement) {
            containerElement.innerHTML = ''; // Clear previous grid
            crosswordCluesBody.innerHTML = ''; // Clear previous clues

            if (!layout || layout.layout.length === 0) {
                containerElement.innerHTML = '<p class="text-red-500 font-semibold">Crossword could not be generated with these words.</p>';
                return;
            }

            const gridTable = document.createElement('div'); // Using div for grid layout
            gridTable.classList.add('puzzle-grid');
            gridTable.style.gridTemplateRows = `repeat(${layout.layout.length}, auto)`;

            const cellSize = 40; // Base cell size for interactive grid

            for (let r = 0; r < layout.layout.length; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.classList.add('row');
                rowDiv.style.gridTemplateColumns = `repeat(${layout.layout[r].length}, ${cellSize}px)`;

                for (let c = 0; c < layout.layout[r].length; c++) {
                    const cell = layout.layout[r][c];
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('cell');

                    if (cell === null) {
                        cellDiv.classList.add('inactive'); // Black square
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.dataset.row = r;
                        input.dataset.col = c;
                        input.dataset.char = cell.char; // Store correct char for potential validation/autofill
                        cellDiv.appendChild(input);

                        if (cell.startWord) {
                            const numberSpan = document.createElement('span');
                            numberSpan.classList.add('number');
                            numberSpan.textContent = cell.startWord;
                            cellDiv.appendChild(numberSpan);
                        }
                    }
                    rowDiv.appendChild(cellDiv);
                }
                gridTable.appendChild(rowDiv);
            }
            containerElement.appendChild(gridTable);

            // Render Clues
            layout.entries.forEach((entry, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${entry.position}</td>
                    <td>${entry.clue}</td>
                    <td>
                        <button class="show-answer-btn" data-answer="${entry.word}">Show Answer</button>
                        <span class="answer-text">${entry.word}</span>
                    </td>
                `;
                crosswordCluesBody.appendChild(tr);
            });

            // Add event listeners for show answer buttons
            document.querySelectorAll('.show-answer-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const answerText = e.target.nextElementSibling;
                    if (answerText) {
                        answerText.style.visibility = 'visible';
                    }
                });
            });
        }


        // --- Main Puzzle Generation & PDF Logic ---

        /**
         * Helper function to draw a single puzzle section in the PDF.
         * @param {PDFPage} page - The PDF page to draw on.
         * @param {object} layout - The puzzle layout object.
         * @param {number} startX - X coordinate to start drawing the section.
         * @param {number} currentY - Current Y coordinate on the page (top of the section).
         * @param {number} availableWidth - Available width for the section.
         * @param {number} availableHeight - Available height for the section.
         * @param {PDFPage} font - The standard font.
         * @param {PDFPage} boldFont - The bold font.
         * @param {string} sectionTitleEn - English title for this section.
         * @param {string} sectionTitleVi - Vietnamese title for this section.
         * @param {string} instructionsEn - English instructions for this section.
         * @param {string} instructionsVi - Vietnamese instructions for this section.
         * @param {boolean} isUnscrambleSection - True if this section is for unscrambling words.
         * @param {boolean} isCrosswordSectionEmpty - True if the crossword grid is empty.
         * @param {boolean} isWordSearchSection - True if this section is for the word search.
         * @returns {number} The new currentY after drawing the section.
         */
        async function drawPuzzleSection(page, layout, startX, currentY, availableWidth, availableHeight, font, boldFont, sectionTitleEn, sectionTitleVi, instructionsEn, instructionsVi, isUnscrambleSection, isCrosswordSectionEmpty, isWordSearchSection) {
            const titleSize = 20;
            const instructionSize = 10;
            const instructionLineHeight = 12;
            const clueLineHeight = 15;
            const clueImageWidth = 15;
            const clueImageMargin = 5;
            const blankLineLength = 40; // Length of the blank line for unscramble

            // Draw Section Title (English)
            page.drawText(sectionTitleEn, {
                x: startX,
                y: currentY - titleSize,
                font: boldFont,
                size: titleSize,
                color: rgb(0, 0, 0),
            });
            currentY -= titleSize + 5; // Small gap between English and Vietnamese title

            // Draw Section Title (Vietnamese)
            page.drawText(sectionTitleVi, {
                x: startX,
                y: currentY - titleSize * 0.7, // Smaller size for Vietnamese title
                font: boldFont,
                size: titleSize * 0.7,
                color: rgb(0, 0, 0),
            });
            currentY -= titleSize * 0.7 + 10; // Gap after title

            // Draw Instructions (English)
            page.drawText(`Instructions: ${instructionsEn}`, {
                x: startX,
                y: currentY - instructionSize,
                font: font,
                size: instructionSize,
                color: rgb(0.3, 0.3, 0.3),
            });
            currentY -= instructionSize + 2;

            // Draw Instructions (Vietnamese)
            page.drawText(`Hướng dẫn: ${instructionsVi}`, {
                x: startX,
                y: currentY - instructionSize,
                font: font,
                size: instructionSize,
                color: rgb(0.3, 0.3, 0.3),
            });
            currentY -= instructionSize + 15; // Gap after instructions

            if (!isUnscrambleSection && !isCrosswordSectionEmpty && !isWordSearchSection) { // Main Crossword Grid
                const layoutRows = layout.layout.length;
                const layoutCols = layout.layout[0].length;

                const estimatedCluesHeight = layout.entries.length * clueLineHeight;
                const remainingHeightForGrid = availableHeight - (titleSize + instructionLineHeight * 2 + 15) - estimatedCluesHeight - 20; // Adjusted for instructions

                let cellSize = Math.min(
                    availableWidth / layoutCols,
                    remainingHeightForGrid / layoutRows,
                    40 // Max cell size from reference
                );
                cellSize = Math.max(cellSize, 27); // Min cell size for readability from reference

                const gridHeight = layoutRows * cellSize;
                const gridWidth = layoutCols * cellSize;
                const gridStartX = startX;
                const gridStartY = currentY - gridHeight - 10; // 10px buffer below instructions
                currentY = gridStartY; // Update currentY to be at the top of the grid

                // Draw crossword grid
                for (let r = 0; r < layout.layout.length; r++) {
                    for (let c = 0; c < layout.layout[r].length; c++) {
                        const cell = layout.layout[r][c];
                        const x = gridStartX + c * cellSize;
                        const y = gridStartY + (layout.layout.length - 1 - r) * cellSize; // PDF coordinates are from bottom-left

                        if (cell === null) { // Black square (inactive in reference)
                            page.drawRectangle({
                                x: x, y: y, width: cellSize, height: cellSize, color: rgb(0, 0.5, 0), // Green background for inactive
                            });
                        } else { // White square (active in reference)
                            page.drawRectangle({
                                x: x, y: y, width: cellSize, height: cellSize,
                                borderColor: rgb(0, 0.5, 0), // Green border
                                borderWidth: 1, // 1px border
                                color: rgb(1, 1, 1), // White background
                            });

                            if (cell.startWord) {
                                page.drawText(cell.startWord.toString(), {
                                    x: x + 3, // Left offset from reference
                                    y: y + cellSize - (cellSize * 0.2) - 5, // Adjusted for top-left and bottom 45px relative
                                    font: font, size: cellSize * 0.2, // Small font size from reference
                                    color: rgb(0, 0, 0),
                                });
                            }
                        }
                    }
                }
            } else if (isWordSearchSection) { // Word Search Grid
                const wsGrid = layout.layout; // layout.layout will be the actual wordSearchGrid
                const layoutRowsWS = wsGrid.length;
                const layoutColsWS = wsGrid[0].length;

                // Calculate remaining available vertical space for word search grid
                const remainingSpaceForWS = availableHeight - (titleSize + instructionLineHeight * 2 + 15); // Adjusted for instructions

                let wsCellSize = Math.min(
                    (availableWidth / layoutColsWS), // Fit horizontally
                    (remainingSpaceForWS - 20) / layoutRowsWS, // Fit grid vertically (20px buffer)
                    15 // Max cell size
                );
                wsCellSize = Math.max(wsCellSize, 8);

                const wsGridHeight = layoutRowsWS * wsCellSize;
                const wsGridWidth = layoutColsWS * wsCellSize;
                const wsGridStartX = startX;
                const wsGridStartY = currentY - wsGridHeight - 10; // 10px buffer below instructions
                currentY = wsGridStartY; // Update currentY to be at the top of the grid for the grid itself

                // Draw word search grid
                for (let r = 0; r < wsGrid.length; r++) {
                    for (let c = 0; c < wsGrid[r].length; c++) {
                        const char = wsGrid[r][c];
                        const x = wsGridStartX + c * wsCellSize;
                        const y = wsGridStartY + (wsGrid.length - 1 - r) * wsCellSize; // PDF coordinates are from bottom-left

                        page.drawRectangle({
                            x: x, y: y, width: wsCellSize, height: wsCellSize,
                            borderColor: rgb(0.3, 0.3, 0.3),
                            borderWidth: 0.7,
                        });
                        page.drawText(char, {
                            x: x + wsCellSize / 2 - font.widthOfTextAtSize(char, wsCellSize * 0.6) / 2,
                            y: y + wsCellSize / 2 - (wsCellSize * 0.6) / 2 + 1,
                            font: font, size: wsCellSize * 0.6,
                            color: rgb(0, 0, 0),
                        });
                    }
                }
            } else if (isCrosswordSectionEmpty) {
                // If crossword section is empty, just print a message instead of a grid
                page.drawText('No crossword puzzle could be generated with the provided words.', {
                    x: startX,
                    y: currentY - 30,
                    font: font,
                    size: 12,
                    color: rgb(0.5, 0.5, 0.5),
                });
                page.drawText('Không thể tạo ô chữ với các từ đã cung cấp.', {
                    x: startX,
                    y: currentY - 45,
                    font: font,
                    size: 12,
                    color: rgb(0.5, 0.5, 0.5),
                });
                currentY -= 60; // Adjust Y for the message
            }

            // Draw clues
            const clueStartX = isUnscrambleSection || isCrosswordSectionEmpty ? startX : (gridStartX + gridWidth + 20);
            let clueYOffset = isUnscrambleSection || isCrosswordSectionEmpty ? currentY : (gridStartY + gridHeight - 10);

            // Draw "Clues:" on the same line as the first clue
            if (layout.entries.length > 0 && !isWordSearchSection) { // Ensure clues are not drawn for word search
                const firstEntry = layout.entries[0];
                let firstClueText;
                if (isUnscrambleSection) {
                    firstClueText = `${firstEntry.position}. "${firstEntry.clue}" = ${'_'.repeat(firstEntry.word.length)}`;
                } else {
                    firstClueText = `${firstEntry.position}. ${firstEntry.clue}`;
                }
                const combinedClueText = `Clues: ${firstClueText}`;

                const imageUrl = `https://placehold.co/${clueImageWidth}x${clueImageWidth}/${Math.floor(Math.random()*16777215).toString(16)}/FFF?text=${firstEntry.word.charAt(0)}`;

                try {
                    const imageBytes = await fetch(imageUrl).then(res => res.arrayBuffer());
                    const image = await pdfDoc.embedPng(imageBytes);
                    page.drawImage(image, {
                        x: clueStartX,
                        y: clueYOffset - (clueLineHeight / 2) - (clueImageWidth / 2),
                        width: clueImageWidth,
                        height: clueImageWidth,
                    });
                    page.drawText(combinedClueText, {
                        x: clueStartX + clueImageWidth + clueImageMargin,
                        y: clueYOffset,
                        font: font,
                        size: 10,
                        color: rgb(0, 0, 0),
                    });
                } catch (imgError) {
                    console.warn(`Could not fetch image for ${firstEntry.word}:`, imgError);
                    page.drawText(combinedClueText, {
                        x: clueStartX,
                        y: clueYOffset,
                        font: font,
                        size: 10,
                        color: rgb(0, 0, 0),
                    });
                }
                clueYOffset -= clueLineHeight; // Move Y down for the next clue

                // Draw remaining clues
                for (let i = 1; i < layout.entries.length; i++) {
                    const entry = layout.entries[i];
                    let clueText;
                    if (isUnscrambleSection) {
                        clueText = `${entry.position}. "${entry.clue}" = ${'_'.repeat(entry.word.length)}`;
                    } else {
                        clueText = `${entry.position}. ${entry.clue}`;
                    }
                    const imageUrl = `https://placehold.co/${clueImageWidth}x${clueImageWidth}/${Math.floor(Math.random()*16777215).toString(16)}/FFF?text=${entry.word.charAt(0)}`;

                    try {
                        const imageBytes = await fetch(imageUrl).then(res => res.arrayBuffer());
                        const image = await pdfDoc.embedPng(imageBytes);
                        page.drawImage(image, {
                            x: clueStartX,
                            y: clueYOffset - (clueLineHeight / 2) - (clueImageWidth / 2),
                            width: clueImageWidth,
                            height: clueImageWidth,
                        });
                        page.drawText(clueText, {
                            x: clueStartX + clueImageWidth + clueImageMargin,
                            y: clueYOffset,
                            font: font,
                            size: 10,
                            color: rgb(0, 0, 0),
                        });
                    } catch (imgError) {
                        console.warn(`Could not fetch image for ${entry.word}:`, imgError);
                        page.drawText(clueText, {
                            x: clueStartX,
                            y: clueYOffset,
                            font: font,
                            size: 10,
                            color: rgb(0, 0, 0),
                        });
                    }
                    clueYOffset -= clueLineHeight;
                }
            }


            return Math.min(currentY, clueYOffset - 10); // Return the lowest Y used by this section
        }


        /**
         * Generates the PDF document with crossword and word search puzzles.
         * This function now takes pre-generated layout data.
         * @param {string[]} words - The list of words for the puzzles.
         * @param {Array<object>} crosswordLayouts - Array of crossword layout objects (can be one or two).
         * @param {Array<Array<string>>} wordSearchGridData - The generated word search grid.
         */
        async function generatePuzzlesPdf(words, crosswordLayouts, wordSearchGridData) {
            const pdfDoc = await PDFDocument.create();
            const margin = 30;
            const { width, height } = { width: 595.28, height: 841.89 }; // A4 dimensions
            const contentWidth = width - 2 * margin;

            // --- Embed Noto Sans Regular font for Unicode support (e.g., Vietnamese characters) ---
            // This font is fetched from Google Fonts CDN. If this specific URL changes or becomes unavailable,
            // you might need to find an updated URL or host the font file yourself.
            const notoSansRegularUrl = 'https://fonts.gstatic.com/s/notosans/v27/o-0NIpQoQp_R_g_r_g_r_g.ttf';
            const fontBytes = await fetch(notoSansRegularUrl).then(res => res.arrayBuffer());
            const customFont = await pdfDoc.embedFont(fontBytes);

            // For bold text, you would typically embed a separate bold font file (e.g., NotoSans-Bold.ttf).
            // For simplicity and to address the encoding issue, we are using the regular Noto Sans for all text.
            // If explicit bold styling is crucial and not achieved by the regular font's rendering,
            // you would need to find and embed a Noto Sans Bold TTF and pass it as a separate 'boldFont' parameter.
            const font = customFont;
            const boldFont = customFont; // Using the same font for bold, as a bold variant TTF is not explicitly embedded here.


            const accentColor = currentThemeColor ? currentThemeColor.pdf : rgb(0.8, 0.8, 0.8); // Default light gray border

            // --- Helper to draw page border and header ---
            function drawPageBorderAndHeader(page, pageNum) {
                // Draw border
                page.drawRectangle({
                    x: margin / 2,
                    y: margin / 2,
                    width: width - margin,
                    height: height - margin,
                    borderColor: accentColor,
                    borderWidth: 5,
                    opacity: 0.8,
                    borderOpacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round',
                    dashArray: [5, 5],
                });

                let currentY = height - margin; // Start from top margin for content

                // Header (Removed "Puzzle Fun!" and "Made by Rene")
                const studentNameLineSize = 12;
                const headerSpacing = 20;

                page.drawText('Student name: _________________', {
                    x: margin,
                    y: currentY - studentNameLineSize,
                    font: font, // Use custom font
                    size: studentNameLineSize,
                    color: rgb(0, 0, 0),
                });
                currentY -= studentNameLineSize + 40; // More space after header block

                if (pageNum > 1) {
                    page.drawText(`Page ${pageNum}`, { x: width - margin - 50, y: height - margin + 10, font: font, size: 8 }); // Use custom font
                }

                return currentY;
            }

            let currentPage = pdfDoc.addPage();
            let currentYPage = drawPageBorderAndHeader(currentPage, 1);

            // --- Separate layouts for ordering ---
            let unscrambleLayout = null;
            let mainCrosswordLayout = null;

            crosswordLayouts.forEach(layoutObj => {
                if (layoutObj.title === 'Additional Crossword Clues') {
                    unscrambleLayout = layoutObj;
                } else if (layoutObj.title === 'Crossword Puzzle') {
                    mainCrosswordLayout = layoutObj;
                }
            });

            // --- Draw Unscramble the Word Section (if exists) ---
            if (unscrambleLayout && unscrambleLayout.layout.entries.length > 0) {
                const titleEn = 'Unscramble the Word';
                const titleVi = 'Giải mã từ';
                const instructionsEn = 'Unscramble the scrambled words below and write the correct word in the blank.';
                const instructionsVi = 'Giải mã các từ bị xáo trộn bên dưới và viết từ đúng vào chỗ trống.';

                const estimatedHeight = 20 + 15 + (unscrambleLayout.layout.entries.length * 15) + 30 + (12 * 2 + 15); // Title, instructions, clues, buffer
                if (currentYPage - estimatedHeight < margin) {
                    currentPage = pdfDoc.addPage();
                    currentYPage = drawPageBorderAndHeader(currentPage, pdfDoc.getPages().length);
                }
                currentYPage = await drawPuzzleSection(
                    currentPage,
                    unscrambleLayout.layout,
                    margin,
                    currentYPage,
                    contentWidth,
                    height, // Pass full height as grid is not drawn
                    font, // Use custom font
                    boldFont, // Use custom font
                    titleEn,
                    titleVi,
                    instructionsEn,
                    instructionsVi,
                    true, // Indicate this is an unscramble section
                    false, // Not an empty crossword grid
                    false // Not a word search section
                );
                currentYPage -= 30;
            }

            // --- Draw Main Crossword Puzzle Section (if exists or needs to be blank) ---
            const crosswordTitleEn = 'Crossword Puzzle';
            const crosswordTitleVi = 'Ô chữ';
            const crosswordInstructionsEn = 'Solve the crossword puzzle by filling in the words based on the clues.';
            const crosswordInstructionsVi = 'Giải ô chữ bằng cách điền các từ dựa trên gợi ý.';

            let isCrosswordEmpty = (!mainCrosswordLayout || mainCrosswordLayout.layout.length === 0);
            let crosswordLayoutToDraw = mainCrosswordLayout ? mainCrosswordLayout.layout : { layout: [], entries: [] }; // Provide empty layout if none generated

            // Estimate height for crossword section (even if empty, it takes space for title/instructions)
            let estimatedCrosswordHeight = 20 + 15 + (12 * 2 + 15) + 30; // Title, instructions, buffer
            if (!isCrosswordEmpty) {
                estimatedCrosswordHeight += (crosswordLayoutToDraw.layout.length * 40) + (crosswordLayoutToDraw.entries.length * 15); // Add grid and clue height if not empty
            } else {
                estimatedCrosswordHeight += 60; // Space for "no crossword" message
            }

            if (currentYPage - estimatedCrosswordHeight < margin) {
                currentPage = pdfDoc.addPage();
                currentYPage = drawPageBorderAndHeader(currentPage, pdfDoc.getPages().length);
            }
            currentYPage = await drawPuzzleSection(
                currentPage,
                crosswordLayoutToDraw,
                margin,
                currentYPage,
                contentWidth,
                height, // Pass full height
                font, // Use custom font
                boldFont, // Use custom font
                crosswordTitleEn,
                crosswordTitleVi,
                crosswordInstructionsEn,
                crosswordInstructionsVi,
                false, // Not an unscramble section
                isCrosswordEmpty, // Indicate if the crossword grid is empty
                false // Not a word search section
            );
            currentYPage -= 30;


            // --- Draw Word Search Puzzle Section ---
            const wordSearchTitleEn = 'Word Search Puzzle';
            const wordSearchTitleVi = 'Tìm từ';
            const wordSearchInstructionsEn = 'Find all the hidden words in the grid. Words can be found horizontally, vertically, or diagonally.';
            const wordSearchInstructionsVi = 'Tìm tất cả các từ ẩn trong lưới. Các từ có thể được tìm thấy theo chiều ngang, chiều dọc hoặc đường chéo.';

            const wordSearchGrid = wordSearchGridData; // Use the pre-generated grid

            const layoutRowsWS = wordSearchGrid.length;
            const layoutColsWS = wordSearchGrid[0].length;

            const estimatedWordSearchHeight = 20 + 15 + (12 * 2 + 15) + (layoutRowsWS * 15) + 30; // Title, instructions, grid, buffer
            if (currentYPage - estimatedWordSearchHeight < margin) {
                currentPage = pdfDoc.addPage();
                currentYPage = drawPageBorderAndHeader(currentPage, pdfDoc.getPages().length);
            }

            currentYPage = await drawPuzzleSection(
                currentPage,
                { layout: wordSearchGrid, entries: [] }, // Pass wordSearchGrid as layout.layout
                margin,
                currentYPage,
                contentWidth,
                height,
                font, // Use custom font
                boldFont, // Use custom font
                wordSearchTitleEn,
                wordSearchTitleVi,
                wordSearchInstructionsEn,
                wordSearchInstructionsVi,
                false, // Not unscramble
                false, // Not an empty crossword
                true // THIS IS THE NEW PARAMETER
            );
            currentYPage -= 30; // Buffer space after word search section


            // Save the PDF
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            // Attempt to open in a new window
            const newWindow = window.open(url, '_blank');

            // If the new window is blocked, trigger a download
            if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                pdfDownloadMessage.style.display = 'block'; // Show message
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Puzzles.pdf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } else {
                pdfDownloadMessage.style.display = 'none'; // Hide message if opened successfully
            }

            // Revoke the object URL after a short delay
            setTimeout(() => URL.revokeObjectURL(url), 10000);
        }

        // --- Event Listeners ---
        wordInput.addEventListener('input', () => {
            if (!validateInput(wordInput.value)) {
                errorMessage.classList.remove('hidden');
                generatePuzzlesBtn.disabled = true;
            } else {
                errorMessage.classList.add('hidden');
                generatePuzzlesBtn.disabled = false;
            }
        });

        easyAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.easyAnimals.join(', ');
            applyThemeStyling('easyAnimals');
            errorMessage.classList.add('hidden'); // Clear error if any
            generatePuzzlesBtn.disabled = false;
        });

        farmAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.farmAnimals.join(', ');
            applyThemeStyling('farmAnimals');
            errorMessage.classList.add('hidden');
            generatePuzzlesBtn.disabled = false;
        });

        oceanAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.oceanAnimals.join(', ');
            applyThemeStyling('oceanAnimals');
            errorMessage.classList.add('hidden');
            generatePuzzlesBtn.disabled = false;
        });

        resetBtn.addEventListener('click', resetApp);

        generatePuzzlesBtn.addEventListener('click', async () => {
            const rawWords = wordInput.value;
            if (!validateInput(rawWords)) {
                errorMessage.classList.remove('hidden');
                return;
            }
            errorMessage.classList.add('hidden');

            const words = rawWords.split(/[\n,]+/)
                                  .map(word => word.trim().toUpperCase()) // Convert to uppercase for consistency
                                  .filter(word => word.length > 0);

            if (words.length === 0) {
                alert('Please enter some words to generate puzzles.');
                return;
            }

            loadingOverlay.classList.remove('hidden');
            generatePuzzlesBtn.disabled = true;
            pdfDownloadMessage.style.display = 'none'; // Hide any previous messages

            activeWordsForPuzzles = words; // Store words for both interactive and PDF generation

            try {
                // Increment iteration number and update label
                puzzleIteration++;
                iterationLabel.textContent = `(Iteration: ${puzzleIteration})`;

                // --- Generate Crossword Layout(s) ---
                generatedCrosswordLayouts = [];
                const crosswordWordsFormatted = words.map(word => ({
                    word: word,
                    clue: scrambleWord(word.toLowerCase()) // Removed length hint from clue
                }));

                let placedWordsInMainLayouts = new Set();

                // Attempt to generate a main crossword with all words
                let mainCrosswordResult = null;
                try {
                    const maxWordLength = Math.max(...words.map(w => w.length));
                    const totalChars = words.join('').length;
                    const crosswordGridProposedSize = Math.max(20, maxWordLength * 2, Math.ceil(Math.sqrt(totalChars * 2)) + 5);
                    mainCrosswordResult = window.CrosswordLayout.generate(crosswordWordsFormatted, {
                        maxGridSize: crosswordGridProposedSize,
                        maxAttempts: 5000
                    });

                    if (mainCrosswordResult && mainCrosswordResult.layout.length > 0) {
                        generatedCrosswordLayouts.push({ layout: mainCrosswordResult, title: 'Crossword Puzzle' });
                        mainCrosswordResult.entries.forEach(entry => placedWordsInMainLayouts.add(entry.word));
                    } else {
                        throw new Error("Main crossword layout failed.");
                    }
                } catch (e) {
                    console.warn(e.message);
                    // If main crossword fails, ensure it's still added to the layouts array as an empty one
                    generatedCrosswordLayouts.push({ layout: { layout: [], entries: [] }, title: 'Crossword Puzzle' });
                }

                // Identify unplaced words and create a combined unscramble section for them
                const unplacedWords = crosswordWordsFormatted.filter(wordObj => !placedWordsInMainLayouts.has(wordObj.word));

                if (unplacedWords.length > 0) {
                    const unscrambleEntries = [];
                    unplacedWords.forEach((wordObj) => {
                        unscrambleEntries.push({
                            position: null, // Will be re-numbered later
                            word: wordObj.word,
                            clue: wordObj.clue, // Already scrambled
                            direction: 'across', // Arbitrary
                            start: { x: 0, y: 0 } // Dummy
                        });
                    });

                    // Add a single combined layout for all unscramble words
                    generatedCrosswordLayouts.unshift({ // Add to the beginning so it's processed first for PDF
                        layout: { layout: [], entries: unscrambleEntries }, // No grid for unscramble
                        title: 'Additional Crossword Clues' // This title will be used to identify it as the unscramble section
                    });
                }

                // Re-number all crossword entries sequentially across all generated layouts
                let currentClueNumber = 1;
                generatedCrosswordLayouts.forEach(cw => {
                    cw.layout.entries.forEach(entry => {
                        entry.position = currentClueNumber++;
                    });
                });


                // --- Generate Word Search Grid ---
                wsGridSize = Math.max(12, Math.ceil(Math.sqrt(words.join('').length)) + 3);
                wsInitializeGrid(); // Reset interactive WS state
                const wordsForWSGeneration = [...words].sort((a, b) => b.length - a.length); // Ensure sorted for placement
                let allWsWordsPlaced = true;
                for (const word of wordsForWSGeneration) {
                    if (!wsPlaceWord(word)) {
                        console.warn(`Could not place word in word search grid: ${word}`);
                        allWsWordsPlaced = false;
                    }
                }
                wsFillEmptySpaces();
                generatedWordSearchGrid = wsGrid; // Store the generated grid for PDF

                // --- Render Interactive Puzzles ---
                // For simplicity, we'll only render the first *main* crossword interactively.
                // If no main crossword, we'll show a message.
                const interactiveMainCrossword = generatedCrosswordLayouts.find(cw => cw.title === 'Crossword Puzzle');
                if (interactiveMainCrossword && interactiveMainCrossword.layout.layout.length > 0) {
                    renderInteractiveCrossword(interactiveMainCrossword.layout, interactiveCrosswordGrid);
                } else {
                    interactiveCrosswordGrid.innerHTML = '<p class="text-red-500 font-semibold">No main crossword puzzle could be generated. See PDF for unscramble clues.</p>';
                }


                generateInteractiveWordSearch(); // Renders the word search grid to the DOM

                // Show puzzle section, hide input section
                appContainer.classList.add('hidden');
                puzzlesSection.classList.remove('hidden');

            }
            catch (error) {
                console.error('Error generating puzzles:', error);
                alert('Failed to generate puzzles. Please try again. Error: ' + error.message);
            } finally {
                loadingOverlay.classList.add('hidden');
                generatePuzzlesBtn.disabled = false;
            }
        });

        // Event listener for Print to PDF button
        printPdfBtn.addEventListener('click', async () => {
            loadingOverlay.classList.remove('hidden');
            printPdfBtn.disabled = true;
            pdfDownloadMessage.style.display = 'none'; // Hide message before attempting again
            try {
                // Pass the stored generated data to the PDF function
                await generatePuzzlesPdf(activeWordsForPuzzles, generatedCrosswordLayouts, generatedWordSearchGrid);
            } catch (error) {
                console.error('Error printing PDF:', error);
                alert('Failed to print PDF. Please try again. Error: ' + error.message);
            } finally {
                loadingOverlay.classList.add('hidden');
                printPdfBtn.disabled = false;
            }
        });

        // Event listener for Back to Input button
        backToInputBtn.addEventListener('click', () => {
            resetApp(); // This will clear everything and go back to input screen
        });


        // Initial check for generate button state
        wordInput.dispatchEvent(new Event('input'));

    </script>
</body>
</html>
