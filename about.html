<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Fun Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- PDF-LIB for PDF generation -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Crossword Layout Generator -->
    <script src="https://unpkg.com/crossword-layout-generator@1.0.0/dist/crossword-layout-generator.umd.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            transition: border-color 0.3s ease-in-out;
            border: 2px solid transparent; /* Default border */
        }
        .theme-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            color: white;
        }
        .theme-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .theme-easy-animals { background-color: #4CAF50; } /* Green */
        .theme-farm-animals { background-color: #8B4513; } /* Brown */
        .theme-ocean-animals { background-color: #2196F3; } /* Blue */

        .generate-button {
            background-color: #4F46E5; /* Indigo */
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .generate-button:hover {
            background-color: #4338CA;
            transform: translateY(-2px);
        }
        .generate-button:disabled {
            background-color: #9CA3AF;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        textarea {
            min-height: 150px;
            border-radius: 0.75rem;
            padding: 1rem;
            border: 2px solid #D1D5DB;
            transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #4F46E5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }
        .error-message {
            color: #EF4444; /* Red */
            font-weight: 600;
            margin-top: 0.5rem;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4F46E5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="app-container" class="container">
        <h1 class="text-4xl font-extrabold text-center text-gray-900 mb-4">Puzzle Fun Generator!</h1>
        <p class="text-md text-center text-gray-600 mb-8">Create custom crossword and word search puzzles.</p>

        <div class="flex flex-col md:flex-row gap-4 mb-6">
            <div class="flex-1">
                <label for="wordInput" class="block text-lg font-semibold text-gray-700 mb-2">Enter your words:</label>
                <textarea
                    id="wordInput"
                    class="w-full focus:ring-indigo-500 focus:border-indigo-500"
                    placeholder="Enter words (e.g., apple, banana, dolphin) or pick a theme below."
                ></textarea>
                <p id="errorMessage" class="error-message hidden">Only letters allowed. Please try again!</p>
            </div>
            <div class="md:w-1/3 flex flex-col gap-3">
                <label class="block text-lg font-semibold text-gray-700 mb-2">Or choose a theme:</label>
                <button id="easyAnimalsBtn" class="theme-button theme-easy-animals">Easy Animals</button>
                <button id="farmAnimalsBtn" class="theme-button theme-farm-animals">Farm Animals</button>
                <button id="oceanAnimalsBtn" class="theme-button theme-ocean-animals">Ocean Animals</button>
                <button id="resetBtn" class="generate-button bg-gray-500 hover:bg-gray-600 mt-4">Reset</button>
            </div>
        </div>

        <button id="generatePdfBtn" class="generate-button w-full">Generate PDF</button>
    </div>

    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>Generating your puzzles...</p>
        <p class="text-sm text-gray-500">This might take a moment as we fetch images and create the PDF.</p>
    </div>

    <script>
        const { PDFDocument, rgb, StandardFonts } = PDFLib;

        // --- UI Elements ---
        const wordInput = document.getElementById('wordInput');
        const errorMessage = document.getElementById('errorMessage');
        const easyAnimalsBtn = document.getElementById('easyAnimalsBtn');
        const farmAnimalsBtn = document.getElementById('farmAnimalsBtn');
        const oceanAnimalsBtn = document.getElementById('oceanAnimalsBtn');
        const resetBtn = document.getElementById('resetBtn');
        const generatePdfBtn = document.getElementById('generatePdfBtn');
        const appContainer = document.getElementById('app-container');
        const loadingOverlay = document.getElementById('loadingOverlay');

        // --- Theme Colors ---
        const themeColors = {
            'easyAnimals': { ui: '#4CAF50', pdf: rgb(0.29, 0.69, 0.29) }, // Green
            'farmAnimals': { ui: '#8B4513', pdf: rgb(0.55, 0.27, 0.07) }, // Brown
            'oceanAnimals': { ui: '#2196F3', pdf: rgb(0.13, 0.59, 0.95) }  // Blue
        };
        let currentThemeColor = null;

        // --- Pre-defined Themes ---
        const themes = {
            'easyAnimals': ['cat', 'dog', 'bird', 'fish', 'bear', 'lion', 'zebra', 'mouse'],
            'farmAnimals': ['cow', 'pig', 'chicken', 'sheep', 'horse', 'goat', 'duck', 'barn'],
            'oceanAnimals': ['dolphin', 'whale', 'shark', 'octopus', 'crab', 'jellyfish', 'seahorse', 'starfish']
        };

        // --- Helper Functions ---

        /**
         * Scrambles a given word.
         * @param {string} word - The word to scramble.
         * @returns {string} The scrambled word.
         */
        function scrambleWord(word) {
            if (word.length <= 1) return word;
            const a = word.split("");
            let n = a.length;
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
            return a.join("");
        }

        /**
         * Validates the input words to ensure they only contain letters.
         * @param {string} input - The raw input string from the textarea.
         * @returns {boolean} True if all words are valid, false otherwise.
         */
        function validateInput(input) {
            const words = input.split(/[\n,]+/).map(word => word.trim()).filter(word => word.length > 0);
            for (const word of words) {
                if (!/^[a-zA-Z]+$/.test(word)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Applies the selected theme's accent color to UI elements.
         * @param {string} themeName - The name of the selected theme.
         */
        function applyThemeStyling(themeName) {
            currentThemeColor = themeColors[themeName];
            if (currentThemeColor) {
                appContainer.style.borderColor = currentThemeColor.ui;
                generatePdfBtn.style.backgroundColor = currentThemeColor.ui;
                generatePdfBtn.style.setProperty('--tw-bg-opacity', '1'); // Ensure Tailwind opacity is overridden
                generatePdfBtn.onmouseover = () => generatePdfBtn.style.backgroundColor = darkenColor(currentThemeColor.ui, 10);
                generatePdfBtn.onmouseout = () => generatePdfBtn.style.backgroundColor = currentThemeColor.ui;
                wordInput.style.borderColor = currentThemeColor.ui;
                wordInput.style.boxShadow = `0 0 0 3px ${currentThemeColor.ui}33`; // Add a subtle shadow
            }
        }

        /**
         * Darkens a hex color by a given percentage.
         * @param {string} hex - The hex color string (e.g., #RRGGBB).
         * @param {number} percent - The percentage to darken (0-100).
         * @returns {string} The darkened hex color.
         */
        function darkenColor(hex, percent) {
            let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=(f>>8)&0x00FF,B=f&0x0000FF;
            return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
        }

        /**
         * Clears all inputs and resets styling.
         */
        function resetApp() {
            wordInput.value = '';
            errorMessage.classList.add('hidden');
            appContainer.style.borderColor = 'transparent';
            generatePdfBtn.style.backgroundColor = '#4F46E5'; // Reset to default indigo
            generatePdfBtn.onmouseover = null;
            generatePdfBtn.onmouseout = null;
            wordInput.style.borderColor = '#D1D5DB';
            wordInput.style.boxShadow = 'none';
            currentThemeColor = null;
        }

        /**
         * Generates a random character (uppercase letter).
         * @returns {string} A random uppercase letter.
         */
        function getRandomChar() {
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }

        /**
         * Generates a word search puzzle grid.
         * @param {string[]} words - An array of words to hide.
         * @param {number} gridSize - The size of the square grid (e.g., 15 for 15x15).
         * @returns {Array<Array<string>>} The word search grid.
         */
        function generateWordSearch(words, gridSize) {
            const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));

            // Sort words by length descending to place longer words first
            words.sort((a, b) => b.length - a.length);

            const directions = [
                { dx: 1, dy: 0 },   // Horizontal
                { dx: 0, dy: 1 },   // Vertical
                { dx: 1, dy: 1 },   // Diagonal (down-right)
                { dx: 1, dy: -1 },  // Diagonal (up-right)
                { dx: -1, dy: 0 },  // Horizontal (backward)
                { dx: 0, dy: -1 },  // Vertical (backward)
                { dx: -1, dy: -1 }, // Diagonal (up-left)
                { dx: -1, dy: 1 }   // Diagonal (down-left)
            ];

            for (const word of words) {
                let placed = false;
                let attempts = 0;
                const maxAttempts = 100;

                while (!placed && attempts < maxAttempts) {
                    attempts++;
                    const startX = Math.floor(Math.random() * gridSize);
                    const startY = Math.floor(Math.random() * gridSize);
                    const dir = directions[Math.floor(Math.random() * directions.length)];

                    let canPlace = true;
                    const cellsToPlace = [];

                    for (let i = 0; i < word.length; i++) {
                        const newX = startX + i * dir.dx;
                        const newY = startY + i * dir.dy;

                        if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                            canPlace = false;
                            break;
                        }
                        // Check if cell is empty or contains the same letter
                        if (grid[newY][newX] !== '' && grid[newY][newX] !== word[i].toUpperCase()) {
                            canPlace = false;
                            break;
                        }
                        cellsToPlace.push({ x: newX, y: newY, char: word[i].toUpperCase() });
                    }

                    if (canPlace) {
                        cellsToPlace.forEach(cell => {
                            grid[cell.y][cell.x] = cell.char;
                        });
                        placed = true;
                    }
                }
            }

            // Fill empty cells with random letters
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === '') {
                        grid[y][x] = getRandomChar();
                    }
                }
            }
            return grid;
        }


        // --- Event Listeners ---
        wordInput.addEventListener('input', () => {
            if (!validateInput(wordInput.value)) {
                errorMessage.classList.remove('hidden');
                generatePdfBtn.disabled = true;
            } else {
                errorMessage.classList.add('hidden');
                generatePdfBtn.disabled = false;
            }
        });

        easyAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.easyAnimals.join(', ');
            applyThemeStyling('easyAnimals');
            errorMessage.classList.add('hidden'); // Clear error if any
            generatePdfBtn.disabled = false;
        });

        farmAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.farmAnimals.join(', ');
            applyThemeStyling('farmAnimals');
            errorMessage.classList.add('hidden');
            generatePdfBtn.disabled = false;
        });

        oceanAnimalsBtn.addEventListener('click', () => {
            wordInput.value = themes.oceanAnimals.join(', ');
            applyThemeStyling('oceanAnimals');
            errorMessage.classList.add('hidden');
            generatePdfBtn.disabled = false;
        });

        resetBtn.addEventListener('click', resetApp);

        generatePdfBtn.addEventListener('click', async () => {
            const rawWords = wordInput.value;
            if (!validateInput(rawWords)) {
                errorMessage.classList.remove('hidden');
                return;
            }
            errorMessage.classList.add('hidden');

            const words = rawWords.split(/[\n,]+/)
                                  .map(word => word.trim().toUpperCase()) // Convert to uppercase for consistency
                                  .filter(word => word.length > 0);

            if (words.length === 0) {
                alert('Please enter some words to generate puzzles.');
                return;
            }

            loadingOverlay.classList.remove('hidden');
            generatePdfBtn.disabled = true;

            try {
                await generatePuzzlesPdf(words);
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Failed to generate PDF. Please try again. Error: ' + error.message);
            } finally {
                loadingOverlay.classList.add('hidden');
                generatePdfBtn.disabled = false;
            }
        });

        /**
         * Helper function to draw a single crossword puzzle section.
         * @param {PDFPage} page - The PDF page to draw on.
         * @param {object} layout - The crossword layout object from crossword-layout-generator.
         * @param {number} startX - X coordinate to start drawing the section.
         * @param {number} currentY - Current Y coordinate on the page (top of the section).
         * @param {number} availableWidth - Available width for the section.
         * @param {number} availableHeight - Available height for the section.
         * @param {PDFPage} font - The standard font.
         * @param {PDFPage} boldFont - The bold font.
         * @param {string} sectionTitle - Title for this crossword section (e.g., "Crossword Puzzle", "Crossword Puzzle (Part 1)").
         * @returns {number} The new currentY after drawing the section.
         */
        async function drawCrosswordSection(page, layout, startX, currentY, availableWidth, availableHeight, font, boldFont, sectionTitle) {
            const titleSize = 20;
            const titleMarginBottom = 15;
            const clueLineHeight = 15;
            const clueImageWidth = 15;
            const clueImageMargin = 5;

            // Draw Section Title
            page.drawText(sectionTitle, {
                x: startX,
                y: currentY - titleSize,
                font: boldFont,
                size: titleSize,
                color: rgb(0, 0, 0),
            });
            currentY -= titleSize + titleMarginBottom;

            const layoutRows = layout.layout.length;
            const layoutCols = layout.layout[0].length;

            const estimatedCluesHeight = layout.entries.length * clueLineHeight;
            const spaceForGrid = availableHeight - (currentY - (height - margin)); // Space from currentY down to bottom margin, accounting for header already drawn
            // Re-calculate spaceForGrid more accurately:
            // availableHeight passed in is the total height from currentY down to where content can be drawn.
            // We need to subtract the title and clue height from this availableHeight to get space for grid.
            const remainingHeightForGrid = availableHeight - (titleSize + titleMarginBottom) - estimatedCluesHeight - 20; // 20px buffer below grid

            let cellSize = Math.min(
                availableWidth / layoutCols,
                remainingHeightForGrid / layoutRows,
                15 // Max cell size
            );
            cellSize = Math.max(cellSize, 8); // Min cell size for readability

            const gridHeight = layoutRows * cellSize;
            const gridWidth = layoutCols * cellSize;
            const gridStartX = startX;
            const gridStartY = currentY - gridHeight - 10; // 10px buffer below title
            currentY = gridStartY; // Update currentY to be at the top of the grid

            // Draw crossword grid
            for (let r = 0; r < layout.layout.length; r++) {
                for (let c = 0; c < layout.layout[r].length; c++) {
                    const cell = layout.layout[r][c];
                    const x = gridStartX + c * cellSize;
                    const y = gridStartY + (layout.layout.length - 1 - r) * cellSize; // PDF coordinates are from bottom-left

                    if (cell === null) { // Black square
                        page.drawRectangle({
                            x: x, y: y, width: cellSize, height: cellSize, color: rgb(0.2, 0.2, 0.2),
                        });
                    } else { // White square
                        page.drawRectangle({
                            x: x, y: y, width: cellSize, height: cellSize,
                            borderColor: rgb(0.5, 0.5, 0.5), borderWidth: 0.5,
                        });
                        if (cell.char) {
                            page.drawText(cell.char, {
                                x: x + cellSize / 2 - font.widthOfTextAtSize(cell.char, cellSize * 0.5) / 2,
                                y: y + cellSize / 2 - (cellSize * 0.5) / 2,
                                font: font, size: cellSize * 0.5, // Scale font with cell size
                                color: rgb(0, 0, 0),
                            });
                        }
                        if (cell.startWord) {
                            page.drawText(cell.startWord.toString(), {
                                x: x + 1, y: y + cellSize - (cellSize * 0.4) - 2, // Adjust for top-left
                                font: font, size: cellSize * 0.4, // Scale font with cell size
                                color: rgb(0, 0, 0),
                            });
                        }
                    }
                }
            }

            // Draw crossword clues and images
            const clueStartX = gridStartX + gridWidth + 20;
            let clueYOffset = gridStartY + gridHeight - 10; // Start clues near top of grid

            page.drawText('Clues:', {
                x: clueStartX,
                y: clueYOffset,
                font: boldFont,
                size: 14,
                color: rgb(0, 0, 0),
            });
            clueYOffset -= 20;

            for (const entry of layout.entries) {
                const clueText = `${entry.position}. ${entry.clue}`;
                // Simulate image fetching with placehold.co
                const imageUrl = `https://placehold.co/${clueImageWidth}x${clueImageWidth}/${Math.floor(Math.random()*16777215).toString(16)}/FFF?text=${entry.word.charAt(0)}`;

                try {
                    const imageBytes = await fetch(imageUrl).then(res => res.arrayBuffer());
                    const image = await pdfDoc.embedPng(imageBytes);
                    page.drawImage(image, {
                        x: clueStartX,
                        y: clueYOffset - (clueLineHeight / 2) - (clueImageWidth / 2), // Center image vertically with text
                        width: clueImageWidth,
                        height: clueImageWidth,
                    });
                    page.drawText(clueText, {
                        x: clueStartX + clueImageWidth + clueImageMargin, // Offset text to make space for image
                        y: clueYOffset,
                        font: font,
                        size: 10,
                        color: rgb(0, 0, 0),
                    });
                } catch (imgError) {
                    console.warn(`Could not fetch image for ${entry.word}:`, imgError);
                    page.drawText(clueText + ' (Image failed)', { // Fallback if image fails
                        x: clueStartX,
                        y: clueYOffset,
                        font: font,
                        size: 10,
                        color: rgb(0, 0, 0),
                    });
                }
                clueYOffset -= clueLineHeight;
            }

            return Math.min(currentY, clueYOffset - 10); // Return the lowest Y used by this section
        }


        /**
         * Generates the PDF document with crossword and word search puzzles.
         * @param {string[]} words - The list of words for the puzzles.
         */
        async function generatePuzzlesPdf(words) {
            const pdfDoc = await PDFDocument.create();
            const margin = 30;
            const { width, height } = { width: 595.28, height: 841.89 }; // A4 dimensions
            const contentWidth = width - 2 * margin;

            const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            const accentColor = currentThemeColor ? currentThemeColor.pdf : rgb(0.8, 0.8, 0.8); // Default light gray border

            // --- Helper to draw page border and header ---
            function drawPageBorderAndHeader(page, pageNum) {
                // Draw border
                page.drawRectangle({
                    x: margin / 2,
                    y: margin / 2,
                    width: width - margin,
                    height: height - margin,
                    borderColor: accentColor,
                    borderWidth: 5,
                    opacity: 0.8,
                    borderOpacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round',
                    dashArray: [5, 5],
                });

                let currentY = height - margin; // Start from top margin for content

                // Header
                const headerTitleSize = 36;
                const headerSubtitleSize = 14;
                const studentNameLineSize = 12;
                const headerSpacing = 20;

                page.drawText('Puzzle Fun!', {
                    x: margin,
                    y: currentY - headerTitleSize,
                    font: boldFont,
                    size: headerTitleSize,
                    color: rgb(0, 0, 0),
                });
                currentY -= headerTitleSize + headerSpacing;

                page.drawText('Made by Rene', {
                    x: margin,
                    y: currentY - headerSubtitleSize,
                    font: font,
                    size: headerSubtitleSize,
                    color: rgb(0.3, 0.3, 0.3),
                });
                currentY -= headerSubtitleSize + headerSpacing;

                page.drawText('Student name: _________________', {
                    x: margin,
                    y: currentY - studentNameLineSize,
                    font: font,
                    size: studentNameLineSize,
                    color: rgb(0, 0, 0),
                });
                currentY -= studentNameLineSize + 40; // More space after header block

                if (pageNum > 1) {
                    page.drawText(`Page ${pageNum}`, { x: width - margin - 50, y: height - margin + 10, font: font, size: 8 });
                }

                return currentY;
            }

            let page1 = pdfDoc.addPage();
            let currentYPage1 = drawPageBorderAndHeader(page1, 1);

            const crosswordsToDraw = [];
            const crosswordWordsFormatted = words.map(word => ({
                word: word,
                clue: scrambleWord(word.toLowerCase()) + ` (${word.length} letters)`
            }));

            // --- Attempt to generate a single crossword first ---
            try {
                const maxWordLength = Math.max(...words.map(w => w.length));
                const crosswordGridProposedSize = Math.max(15, maxWordLength + 5, words.length * 2);
                const fullCrosswordLayout = window.CrosswordLayout.generate(crosswordWordsFormatted, {
                    maxGridSize: crosswordGridProposedSize,
                    maxAttempts: 1000 // Increased attempts
                });

                if (fullCrosswordLayout && fullCrosswordLayout.layout.length > 0) {
                    crosswordsToDraw.push({ layout: fullCrosswordLayout, title: 'Crossword Puzzle' });
                } else {
                    throw new Error("Single crossword layout failed, attempting split.");
                }
            } catch (e) {
                console.warn(e.message);
                // --- If single crossword fails, split and attempt two ---
                // Shuffle words to distribute complexity
                const shuffledWords = [...crosswordWordsFormatted].sort(() => 0.5 - Math.random());
                const mid = Math.ceil(shuffledWords.length / 2);
                const wordsPart1 = shuffledWords.slice(0, mid);
                const wordsPart2 = shuffledWords.slice(mid);

                let layout1 = null;
                if (wordsPart1.length >= 3) { // Require at least 3 words for a meaningful puzzle
                    try {
                        const maxWordLength1 = Math.max(...wordsPart1.map(w => w.word.length || 0)); // Handle empty array
                        const gridProposedSize1 = Math.max(12, maxWordLength1 + 3, wordsPart1.length * 2);
                        layout1 = window.CrosswordLayout.generate(wordsPart1, {
                            maxGridSize: gridProposedSize1,
                            maxAttempts: 500
                        });
                        if (layout1 && layout1.layout.length > 0) {
                            crosswordsToDraw.push({ layout: layout1, title: 'Crossword Puzzle (Part 1)' });
                        }
                    } catch (subError) { console.warn("Part 1 crossword failed:", subError.message); }
                }

                let layout2 = null;
                if (wordsPart2.length >= 3) {
                    try {
                        const maxWordLength2 = Math.max(...wordsPart2.map(w => w.word.length || 0)); // Handle empty array
                        const gridProposedSize2 = Math.max(12, maxWordLength2 + 3, wordsPart2.length * 2);
                        layout2 = window.CrosswordLayout.generate(wordsPart2, {
                            maxGridSize: gridProposedSize2,
                            maxAttempts: 500
                        });
                        if (layout2 && layout2.layout.length > 0) {
                            crosswordsToDraw.push({ layout: layout2, title: 'Crossword Puzzle (Part 2)' });
                        }
                    } catch (subError) { console.warn("Part 2 crossword failed:", subError.message); }
                }

                if (crosswordsToDraw.length === 0) {
                    page1.drawText("Crossword puzzle(s) could not be generated with the given words. Please try different words or fewer words.", {
                        x: margin, y: currentYPage1 - 50, font: font, size: 10, color: rgb(1, 0, 0)
                    });
                    currentYPage1 -= 60;
                }
            }


            // --- Draw Crosswords ---
            let currentPageForWS = page1; // This page will hold the Word Search and Word Bank
            let currentYForWS = currentYPage1;

            if (crosswordsToDraw.length > 0) {
                // Draw the first crossword on page1
                const availableCrosswordHeight1 = currentYPage1 - margin - 20; // currentY to bottom margin, less some buffer
                currentYForWS = await drawCrosswordSection(
                    page1,
                    crosswordsToDraw[0].layout,
                    margin,
                    currentYPage1, // Pass the starting Y for the section
                    contentWidth,
                    availableCrosswordHeight1,
                    font,
                    boldFont,
                    crosswordsToDraw[0].title
                );
                currentYForWS -= 30; // Buffer space after first crossword section
            }

            // --- If there's a second crossword, add a new page for it ---
            if (crosswordsToDraw.length > 1) {
                let page2 = pdfDoc.addPage();
                let currentYPage2 = drawPageBorderAndHeader(page2, 2); // Draw header on second page

                const availableCrosswordHeight2 = currentYPage2 - margin - 20; // currentY to bottom margin, less some buffer
                currentYForWS = await drawCrosswordSection(
                    page2,
                    crosswordsToDraw[1].layout,
                    margin,
                    currentYPage2, // Pass the starting Y for the section
                    contentWidth,
                    availableCrosswordHeight2,
                    font,
                    boldFont,
                    crosswordsToDraw[1].title
                );
                currentPageForWS = page2; // Word Search and Word Bank will go on page 2
                currentYForWS -= 30; // Buffer space after second crossword section
            }


            // --- Word Search Puzzle Section (always follows the last drawn crossword or header if no crosswords) ---
            const wordSearchTitleSize = 20;
            const wordSearchTitleMarginBottom = 15;
            const wordBankLineHeight = 15;

            currentYForWS -= wordSearchTitleSize + wordSearchTitleMarginBottom + 20; // Extra space before word search title

            currentPageForWS.drawText('Word Search Puzzle', {
                x: margin,
                y: currentYForWS,
                font: boldFont,
                size: wordSearchTitleSize,
                color: rgb(0, 0, 0),
            });
            currentYForWS -= wordSearchTitleSize + wordSearchTitleMarginBottom;

            const wordSearchGridSize = Math.max(12, Math.ceil(Math.sqrt(words.join('').length)) + 3);
            const wordSearchGrid = generateWordSearch(words, wordSearchGridSize);

            const layoutRowsWS = wordSearchGrid.length;
            const layoutColsWS = wordSearchGrid[0].length;

            // Calculate remaining available vertical space for word search grid + word bank
            const remainingSpaceForWS = currentYForWS - margin - 20; // 20px buffer for bottom margin

            let wsCellSize = Math.min(
                (contentWidth / layoutColsWS), // Fit horizontally
                (remainingSpaceForWS - (Math.ceil(words.length / 2) * wordBankLineHeight) - 20) / layoutRowsWS, // Fit grid vertically
                15 // Max cell size
            );
            // Ensure min cell size for readability
            wsCellSize = Math.max(wsCellSize, 8);


            const wsGridHeight = layoutRowsWS * wsCellSize;
            const wsGridWidth = layoutColsWS * wsCellSize;
            const wsGridStartX = margin;
            const wsGridStartY = currentYForWS - wsGridHeight - 10; // 10px buffer below title
            currentYForWS = wsGridStartY; // Update currentY to below the grid

            // Draw word search grid
            for (let r = 0; r < wordSearchGrid.length; r++) {
                for (let c = 0; c < wordSearchGrid[r].length; c++) {
                    const char = wordSearchGrid[r][c];
                    const x = wsGridStartX + c * wsCellSize;
                    const y = wsGridStartY + (wordSearchGrid.length - 1 - r) * wsCellSize;

                    currentPageForWS.drawRectangle({
                        x: x, y: y, width: wsCellSize, height: wsCellSize,
                        borderColor: rgb(0.3, 0.3, 0.3), // Darker border for word search
                        borderWidth: 0.7, // Slightly thicker border
                    });
                    currentPageForWS.drawText(char, {
                        x: x + wsCellSize / 2 - font.widthOfTextAtSize(char, wsCellSize * 0.6) / 2,
                        y: y + wsCellSize / 2 - (wsCellSize * 0.6) / 2 + 1, // +1 for slight vertical adjustment
                        font: font, size: wsCellSize * 0.6, // Scale font with cell size
                        color: rgb(0, 0, 0),
                    });
                }
            }

            // Word Bank
            const wordBankStartX = wsGridStartX + wsGridWidth + 20;
            let wordBankYOffset = wsGridStartY + wsGridHeight - 10; // Align with top of word search grid

            currentPageForWS.drawText('Word Bank:', {
                x: wordBankStartX,
                y: wordBankYOffset,
                font: boldFont,
                size: 14,
                color: rgb(0, 0, 0),
            });
            wordBankYOffset -= 20;

            const wordsPerColumn = Math.ceil(words.length / 2); // Two columns for word bank
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const col = Math.floor(i / wordsPerColumn);
                const x = wordBankStartX + (col * 100); // Offset for second column
                const y = wordBankYOffset - (i % wordsPerColumn) * wordBankLineHeight;

                currentPageForWS.drawText(word, {
                    x: x, y: y, font: font, size: 10, color: rgb(0, 0, 0),
                });
            }


            // Save the PDF
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
        }

        // Initial check for generate button state
        wordInput.dispatchEvent(new Event('input'));

    </script>
</body>
</html>
